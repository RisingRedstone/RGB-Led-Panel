
/* USER CODE BEGIN Includes */
#include "Bitmaps.c"
#include <stdlib.h>
#include "../MDK-ARM/HemGfxWrapper.h"
#include <stdlib.h>
/* USER CODE END Includes */


/* USER CODE BEGIN 0 */

const uint8_t Sequence[64] = {
  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
  0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
  0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,
  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
  0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
  0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
  0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18
};

uint16_t *MarioVid[2];

const uint8_t ra[] = {0, 1, 0, 1};
const uint8_t rb[] = {0, 0, 1, 1};

uint16_t map1[512];
uint16_t map2[512];
uint8_t count = 0;

HemGfx_t *h_Gfx;
bool Ready = true;

void WritePin1(uint8_t);
void uploadMatrix1(void);
void uploadMatrix2(void);
void uploadMatrix3(void);

void HemWriteImage(uint16_t *image, int16_t x, int16_t y){
	HemdrawImage(h_Gfx, (image + 2), image[0], image[1], x, y);
}

void SwitchBuffer(HemGfx_t *h_gfx, bool copy, bool ready){
	while(ready == false)
		__NOP();
	
	HemSwitchBuff(h_Gfx, copy);
}

/* USER CODE END 0 *//* USER CODE BEGIN 0 */

const uint8_t Sequence[64] = {
  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
  0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
  0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,
  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
  0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
  0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
  0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18
};

uint16_t *MarioVid[2];

const uint8_t ra[] = {0, 1, 0, 1};
const uint8_t rb[] = {0, 0, 1, 1};

uint16_t map1[512];
uint16_t map2[512];
uint8_t count = 0;

HemGfx_t *h_Gfx;
bool Ready = true;

void WritePin1(uint8_t);
void uploadMatrix1(void);
void uploadMatrix2(void);
void uploadMatrix3(void);

void HemWriteImage(uint16_t *image, int16_t x, int16_t y){
	HemdrawImage(h_Gfx, (image + 2), image[0], image[1], x, y);
}

void SwitchBuffer(HemGfx_t *h_gfx, bool copy, bool ready){
	while(ready == false)
		__NOP();
	
	HemSwitchBuff(h_Gfx, copy);
}

/* USER CODE END 0 */

/* USER CODE BEGIN 1 */
h_Gfx = newHemGfx(32, 16, (uint16_t *)map1, (uint16_t *)map2);
MarioVid[0] = (uint16_t *)MarioVid2;
MarioVid[1] = (uint16_t *)MarioVid4;
/* USER CODE END 1 */

/* USER CODE BEGIN 2 */
HAL_TIM_Base_Start_IT(&htim2);
int16_t temp1 = 0;
/* USER CODE END 2 */

while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
		int16_t temp0;
		for(temp0 = 0; temp0 < 2; temp0++){
			if(temp1 > 32)
				temp1 = -11;
			
			HAL_Delay(100);
			HAL_GPIO_TogglePin(Led_out_GPIO_Port, Led_out_Pin);
			HemClearScreen(h_Gfx);
			HemWriteImage(MarioVid[temp0], temp1, (1 - temp0));
			SwitchBuffer(h_Gfx, true, Ready);
			temp1 += ((temp0 == 0) ? 4 : 3);
		}
	}
  /* USER CODE END 3 */
